import * as Yup from "yup";
import { format, startOfHour, parseISO, isBefore, subHours } from "date-fns";
import pt from "date-fns/locale/pt";
import User from "../models/User";
import File from "../models/File";
import Appointment from "../models/Appointment";
import Notification from "../schemas/Notification";
import Queue from "../../lib/Queue";
import CancellationMail from "../jobs/CancellationMail";

class AppointmentController {
    async index(req, res) {
        const { page = 1 } = req.query;

        const appointments = await Appointment.findAll({
            where: { user_id: req.userId, canceled_at: null },
            order: ["date"],
            limit: 20,
            offset: (page - 1) * 20,
            include: [
                {
                    model: User,
                    as: "provider",
                    attributes: ["id", "name"],
                    include: [
                        {
                            model: File,
                            as: "avatar",
                            attributes: ["id", "path", "url"],
                        },
                    ],
                },
            ],
            attributes: ["id", "date", "past", "cancelable"],
        });

        return res.json(appointments);
    }

    async store(req, res) {
        const schema = Yup.object().shape({
            date: Yup.date().required(),
            user_id: Yup.number(),
            provider_id: Yup.number().required(),
        });

        if (!(await schema.isValid(req.body))) {
            return res.status(400).json({ error: "Validation fails" });
        }

        const { provider_id, date } = req.body;

        if (provider_id === req.userId) {
            return res
                .status(400)
                .json({ error: "User cannot choose himself" });
        }

        const checkisProvider = await User.findOne({
            where: { id: provider_id, provider: true },
        });

        if (!checkisProvider) {
            return res.status(400).json({ error: "User is not a provider" });
        }

        const hourStart = startOfHour(parseISO(date));

        if (isBefore(hourStart, new Date())) {
            return res.status(400).json({ error: "Past date is not allowed" });
        }

        const checkAvailability = await Appointment.findOne({
            where: {
                provider_id,
                canceled_at: null,
                date: hourStart,
            },
        });

        if (checkAvailability) {
            return res
                .status(400)
                .json({ error: "Appointment date is not available" });
        }

        const appointment = await Appointment.create({
            user_id: req.userId,
            provider_id,
            date: hourStart,
        });

        // Notify appointment provider

        const user = await User.findByPk(req.userId);
        const formatedDate = format(
            hourStart,
            "'dia' dd 'de' MMMM', Ã s ' H:mm'h'",
            { locale: pt }
        );

        await Notification.create({
            content: `Novo agendamento de ${user.name} para ${formatedDate}`,
            user: provider_id,
        });

        return res.json(appointment);
    }

    async delete(req, res) {
        const { id } = req.params;

        const appointment = await Appointment.findByPk(id, {
            include: [
                {
                    model: User,
                    as: "provider",
                    attributes: ["name", "email"],
                },
                {
                    model: User,
                    as: "user",
                    attributes: ["name"],
                },
            ],
        });

        if (appointment.user_id !== req.userId) {
            return res.status(401).json({
                error: "You don't have permission to cancel this appointment",
            });
        }

        const dateWithSub = subHours(appointment.date, 2);

        if (isBefore(dateWithSub, new Date())) {
            return res.status(401).json({
                error: "You can only cancel appointments 2 hours in advance",
            });
        }

        appointment.canceled_at = new Date();

        await appointment.save();

        Queue.add(CancellationMail.key, { appointment });

        return res.json(appointment);
    }
}

export default new AppointmentController();
